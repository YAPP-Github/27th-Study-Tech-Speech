## 발표 음성 텍스트

### Java Thread 설명
설명글에서 제가 흥미롭게 발견한 이 기술 블로그를 발견을 했는데요.
이분, 작성하신 분이 자바 언어에 많은 관여를 하셨기 때문에 이분의 기술 글에서 많이 배울 수 있겠다 싶어서 이 글을 기반으로 진행을 하였습니다. 그래서 한번 기회 되시면 보시면 굉장히 좋다고 생각이 들었습니다. 물론 이거를 캡처를 해가지고 제가 밑줄 그르면서 어떤 부분이 중요한지를 파악을 해봤습니다.

그래서 첫 번째는 자바 스레드, 물론 다들 아시겠지만 프로세스 내부에 여러 스레드가 존재하는 것을 모두 알고 있으실 겁니다. 근데 이제 프로세스와의 공통점이 있는데, 공통점은 PC를 갖고, 고유 지역 변수 갖고, 그 다음에 각각의 프로세스와 스레드, 그러니까 프로세스끼리와 스레드끼리는 독립적이라는 걸 알 수 있습니다.

근데 이제 차이점으로는 프로세스와 스레드의 차이점은 스레드는 이 프로세스 간에 보다 격리된 상태가 이제 좀 덜 격리가 되어 있고, 그 다음에 스레드는 이제 가장 큰 특징인 것 같은데 메모리를 공유를 합니다. 그래서 이제 동일한 파일을 다루고, 그 다음에 상태까지 다룬다, 이 뜻은 즉 같은 지역 변수를 공유한다고 저는 이해를 했습니다.

그래서 또 이렇게 쭉 설명을 하는데요. 아까 말씀드렸다시피 프로세스는 여러 스레드를 지원을 하는데, 이 스레드에서는 두 가지 특징이 있습니다. 하나가 컨커런시, 다른 하나가 Asynchronous 라고 이제 형용사로 쓰긴 하는데, 명사형이 이제 어싱크로니, 이제 비동기라고 합니다. 이제 컨커런시를 최대한 압축해서 설명, 이제 표현을 하고 싶었는데, 가장 짧게 제가 제 언어대로 표현을 한 게 여러 주체, 이제 즉 코어 개수죠. 그러니까 여러 주체가 여러 작업을 동시간대 동시에 실행하는 게 이제 컨커런시고, 어싱크로니는 하나의 주체, 그러니까 단일 코어가 작업을 전환하여, 이제 컨텍스트 스위칭하여 작업을 실행한다 라고 이제 이해를 했습니다.

그래서 말씀드렸다시피 하나의 프로세스 내부에 여러 스레드가 존재하는데, 그 스레드끼리는 동일한 메모리 주소를 공유를 하기 때문에 이와 같은 동작이 가능한데, 동일 변수와 동일한 객체에 접근 가능하고, 이러한 것들이 이제 힙에 존재를 할 수 있게 하고, 이런 두 가지 특징이 있습니다. 이 힙은 이렇게 설명했다시피 메모리 구역에서의 동적 할당 객체를 저장하는 구역입니다. 그래서 이 스레드 관련해서 동일 메모리를 이제 공유를 하고, 이제 주의할 점은 이 스레드 간에 있어서 동일 메모리에 접근할 때 주의해야 된다, 물론 다들 알고 계시겠지만 이런 설명이 나와 있었습니다.

그 다음에 이제 버추얼 스레드라는 게 자바 19에서 나왔다고 하는데, 이걸 찾아보니까 코틀린의 코루틴과 비슷하지만, 저는 처음엔 동일하게 동작하는 줄 알았는데 좀 더 깊게 확인해 보니까 다르다는 걸 이제 좀 확인을 했습니다. 물론 이거에 대해서는 기본에 좀 더 충실해야 하기 때문에 이거에 대해서 깊게는 찾아보진 않았는데, 간략하게 보자면은 코틀린은 어싱크 어웨이트를 사용하는데, 이제 자바는 고의 코루틴을 좀 많이 여기에서 영감을 받아서 유저 모드 스레드로서 처리를 한다고 합니다. 물론 이거에 대한 깊은 학습은 별도로 진행을 해야겠지만 일단 그렇다고 합니다. 그래서 이거를 증거하는 영상을 찾아서 이제 여기다가 첨부를 했습니다. 그리고 여기서 다른 문서에서는 이 코루틴과 유저 모드 스레드를 이제 교차하면서 동의어로 쓰는 부분이 있는데, 이게 완벽히 동일한 기능은 아니라는 것을 확인을 했습니다.

일단 다시 돌아와서 자바 스레드 조금 빠르게 하겠습니다. 5분밖에 안 남았네요.

그래서 자바 프로그램은 메인 스레드, 이제 최소 하나 스레드를 갖고 있고, 이 JVM이 자바 프로그램이 실행이 되면 JVM이 메인 스레드 생성하고, 이 메인 스레드로 인해서 이제 메인 메서드를 호출을 합니다. 그 외에 이제 메인 스레드를 통해서 다른 여러 스레드들이 동작을 할 수 있고, 이제 여기서는 다른 라이브러리, 프레임워크를 통해서 여러 스레드를 생성한다고 하는데, 여기에 이제 뭐 안드로이드에 넣으면 된다고 생각을 했습니다. 이것들은 기존 자바 라이브러리, 프레임워크들인데, 여기 뭐 안드로이드도 당연하겠지만 안드로이드라고 생각을 하니까 좀 편리했습니다, 이해하기.

그래서 사용 이유가 뭐냐 하니까 향상된 반응형 UI의 제작, 물론 안드로이드도 하시면서 느끼셨겠고, 그 다음에 현대화된 멀티코어 최대한 적극 활용하시는 거, 모델링의 단순화, 요거는 아직 제가 좀 와닿진 않았지만 일단 모델링이라고 표현을 해 가지고 일단 모델링의 단순화라는 거를 라고 일단 정리를 해놨습니다. 그 다음에 비동기 처리, 백그라운드 처리, UI 상에서 보이지 않는 처리들도 동시에 처리하게끔 하도록 할 수 있다고 합니다. 상관 나가는. 예, 그래서 이제 어떤 특정한 기능이 동시에 두 가지 이상이 필요하게 되면은 이때 스레드를 사용을 해 가지고 백그라운드에서 처리하도록 하는 부분을 설명을 하는 것을 정리를 했습니다. 그래서 멀티프로세스, 멀티코어 CPU에서 최대한 활용을 하기 위해서는 스레드를 쓰는 게 맞고, 이러한 관리를 자바 내에서 할 수 있다 라고 이제 정리를 했습니다.

어, 예. 스레드를 사용을 해서 유지 보수할 수 있는 거를 이제 모델링, 아직은 약간 와닿진 않지만 그렇습니다. 그 다음에 비동기와 백그라운드, 말씀드렸던 것처럼 여기서 예시를 표현을 해서 소켓 통신과 그 다음에 메인 처리를 어떻게 동시에 가능하도록 하느냐에 대해서 설명을 하고 있습니다. 그래서 싱글 스레드로 처리하는 폴링 방식보다는 이 두 가지 이상의 스레드를 사용을 해서 한쪽은 대기하는 동작을 하고, 다른 한쪽 메인 스레드에서는 그 주된 동작을 하는 방식을 이제 예시로써 표현을 했습니다.

어, 그 다음에 여기서 주요한 부분이 나왔습니다. 이게 이제 제가 면접에서 가장 큰 코를 다쳤던 부분인데, 여기서 이제 두 가지를 쓸 수 있다고 이제 포인트, 이제 짚어줍니다. 하나가 `volatile` 키워드를 쓰는 거고, 다른 하나가 싱크로나이제이션, 뭐 싱크로나이즈드일 수도 있고, 아까 말씀하셨던 람다로 이제 블록으로 감싸가지고 사용하는 방식, 아니면 어노테이션이라든지. 그래서 이 부분이 가장 중요한 것 같은데, 이제 공유되는 메모리에 접근하는 모든 메서드들, 모든 행동에 대해서는 항상 동기화가 이제 적용이 되어 있는지를 확인해야 된다고 합니다. 그래서 공유 변수에 접근을 보호한다면 프로그램에서 해당 변수에 접근하는 모든 곳에서 싱크로나이제이션을 사용해야 한다. 그래서 공유되는 메모리에는 항상 싱크로나이제이션이 붙어야 된다 라는 거를 이번에 뼈저리게 느꼈습니다. 그래서 요거 하시면 되고, `volatile`도 가끔 쓰는 것 같긴 한데, 대부분은 싱크로나이제이션 쓴다고 하니까 요거 쓰면 될 것 같습니다 라고 이해를 했습니다. 그렇지만 너무 과도하게 쓰지 말자, 스레드는 자원 소모하니까 이제 어떤 코어를 쓰는지, 어떤 CPU를 쓰는지에 따라서도 멀티스레딩 프로그래밍을 할지 아닐지도 이제 결정을 해야 된다 라고 되어 있습니다.

이제 10초밖에 안 남았으니까 요거에 대한 예시는 그냥 딥다이브를 해서 어떤 거를 확인하고 싶었냐면 이 스타트 메서드를 호출을 했는데 정작 구현한 건 런 메서드였기 때문에 분명 여기까지 하겠습니다. 일단 시간을 지키겠습니다. 네, 질문 해주시면 됩니다. 순서를 제가 설정하는 게 좀 더 편하실까요? 사실 그거까지에 대해서는 제가 정하면은 좀 약간 취지와 맞지 않은데, 제가 강요하는 것처럼 이제 생각이 들까 봐 그래서 자유롭게 해주시면 될 것 같습니다. 네.

### Java Thread 질문 답변
제가 문서만 따라갔다 보니까 여기까지밖에 이것만 딱 알고 이제 넘어가버려 가지고 정확하게는 이제 모릅니다. 그래서 거기에는 제가 또 공부를 해보겠습니다. 벌써 탈락인데요. 이제 제가 확인한 방식 내에서밖에 답변을 못 드리겠는데, 여기서 이제 버추얼 스레드 표현이 나왔거든요. 물론 전부 다 이게 추상적인 언어로 일단 설명이 돼 있어 가지고 깊이는 설명을 못 드리겠지만 이게 스레드 처리에 있어서 굉장히 손붉게 많아지더라구요. 이제 어떤 메서드에서 스레드를 생성을 해 가지고 동작시키는 것들과 다른 쪽 스레드에서 이제 동작하는 거에 대해서 또 공유 메모리에 접근할 때 그 스레드가 많아지면 그거에 대한 처리를 하는 데 있어서 이게 무게가 무겁다라고는 일단 알고 있는데, 그거를 이제 그 스레드 자체를 이제 가볍게 만들어 주는 게 이제 뭐 자바에서는 버추얼 스레드고, 코틀린에서는 코루틴이다 라고는 알고 있지만 이 내부적 단에서는 좀 더 디테일하게 설명을 드릴 순 없을 것 같습니다.

여기 이제 정리한 바와 같이 동시성은 그 각각의 코어가 그 각각의 업무를 병렬적으로 동시간대 처리하는 거고, 이제 아 잠시만요. 동시성과 병렬성. 병렬성이 또 제가 정리한 언어로 표현하자면은 컨커런시와 어싱크로니를 봤을 때 그냥 각 코어가 동시에 실행을 한다. 그 다음에 어싱크로니가 이제 한 코어가 컨텍스트 스위칭을 통해서 여러 업무를 처리한다. 어싱크로니가 한 코어가 컨텍스트 스위칭을 통해서 여러 업무를 처리한다 라고 파악을 했는데, 그렇습니다.

스레드가 더 이상 사용되지 않으면, 일단 그렇다고 일단 알고 있습니다. 내부적으로 예시 코드에서도 이거에 대한 스레드 소거가 없었거든요. 이 예시에서도 이 스레드 자체를 종료시키면 그때 메모리에서 제거가 될 것 같습니다. 이 부분도 조사를 해보겠습니다.

---

## 부족한 부분
1. Concurrency와 Asynchrony 정의가 잘못됨 -> Parallelism 의 개념을 Concurrency 로 설명, Asynchrony 는 Context Switching 을 포함하는 개념이 아닌 비동기 작업 처리 개념
2. Virtual Thread vs Coroutine 차이 -> Virtual Thread 는 User-mode Thread 로 OS Thread 보다 가벼운 JVM 레벨의 스레드이고, Coroutine 은 비동기 프로그래밍을 위한 경량화된 실행 단위로, 둘은 개념과 구현이 다름
3. Thread 종료 및 메모리 해제 과정에 대한 구체적 설명 부족 -> Thread 가 종료되면 JVM 이 해당 Thread 의 자원을 해제하며, 가비지 컬렉션에 의해 메모리가 회수됨
4. Modeling 단순화에 대한 구체적 설명 부족 -> 모델링이란 시스템의 구조와 동작을 추상화하여 표현하는 것을 의미하며, 스레드를 사용하면 복잡한 비동기 작업을 보다 직관적으로 설계할 수 있음

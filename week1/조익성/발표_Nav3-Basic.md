### 발표 시작

이번에 새로운 프로젝트 신 기술 같은 거 도입해보자고 얘기가 나와서
이런 내부 3 나온 지 얼마 안 돼서 참점을 해서 조금 도입을 해서 남들보다 앞서 가보자
라는 생각으로 개인적으로 시작을 하게 됐고요
목차는 왜 현재 원래 있던 게 없어지고 새로 생겼는지
그리고 이제 그냥 기본 개념들 그리고 그 다음에 간단한 사용 문제들 형식으로 하려고 합니다
우선 왜 생겼냐고 하면은 기존에 발표됐던 자료에 따르면은
안드로이드 편하게 내부 2라고 말하면은
내부 2는 안드로이드 X랑 Zpack Compose가 활성화되기 이전인 2018년에 처음 발표가 되었어요
그래서 내부 2는 선언한 UI에 집중하지 않은 라이브러리라고 생각을 하시면 되고요
그리고 이제 좀 선언한 UI가 아닌과 동시에 약간
핸드폰 기기들이나 태블릿들이 좀 UI가 너무 다채로워졌어요
폴드라는 것도 생겼고 플립이라는 것도 생겨 가지고 적응형 UI가 중요시 되고 있습니다
그래서 적응형 UI 관련된 세션도 많이 열린 것 같고
안드로이드 위크의 어댑티브 레이아웃 주도 몇 주 전에 올라온 것 같고
그래서 기존 안드로이드 기존 내부 2에서는 이제 백스택에서 최상위 화면만 보여줬어요
지금도 똑같긴 하지만 최상위 스택만 접근을 할 수 있었어요
저희가 접근할 수 있어서
예를 들면은 오른쪽 사진에 있는 오른쪽 같은 레이아웃을 짜려고 했으면은
실제 프로덕션 되어 있는 다른 뭐 태블릿 카카오톡이나 이런 건 어떻게 될지 모르겠지만
아마 제 생각에는 분기 처리를 해서 위드사이즈 윈도우 클래스에 접근해서
그럼 백스택에서 직접 꺼내는 게 아니라
하나의 스크린에서 사용을 할 것 같습니다
그렇기 때문에 얘네가 이런 말을 한 것 같고
실제 코드를 보면은 도움이 될 것 같은데
그래서 이제 네브3가 지향하는 바는
A도 백스택이고 백스택에 해당하는 컴포넌트이고
컨텐트이고 B도 백스택에 해당하는 컨텐트여서
이제
어
그래서 그냥 모든 화면을 스택으로 관리하고
그 스택을 개발자가 관리하게끔 만들고 싶다라는 건데
이 줄을 설명하면서 다시 말씀드리자면은
네브2는 싱글 소스 오브 트루스를 유지하기 어렵게 만든다
라고 되어 있어요
그래서 화면을 볼 때
이제 뷰 모델이 가지고 있는 UI 상태가 있고
UI 스테이트 같은 그런 UI 상태가 있고
화면에서는 또 네브 컨트롤러가 가지고 있는
라우트 상태 현재 백스택 상태 현재 주소 이런 것들을 화면이 알 수 있습니다
그래서 뭐 어디로 이동을 해야 될지
뒤로 가기를 누르면 어디로 다시 돌아가야 할지
라는 거를 이제 사용을 해야 되는데
화면의 입장에서 이제 소스가 두 개예요
이제 네브 컨트롤러는 완전한 블랙박스여 가지고
화면 이동을 구현을 하려면 네브 컨트롤러의
그 내비게이트 함수를 직접 가져와서
호출을 하는 형식으로 사용을 했어야 돼 가지고
그 안쪽에 백스택이 어떻게 되어 있는지
뭐 정확하게 어떻게 되어 있는지
알 수가 없다 라는 말이었는데
이거는 일단은 살짝 넘어가겠습니다
설명이 잘 되지는 않는 것 같아서
그래서 이제 네브3 핵심 개념은 백스택을 개발자가 관리하고
그 백스택의 최상위를 보여주는 건 맞는데
원한다면은 백스택의 두 개를 접근해서 보여줄 수도 있고
이 글에는 없지만
그래서 요거를 핵심으로 알면 되실 것 같습니다
이게 설명하기가 쉽지는 않네요
그래서 중요한 개념들은
이제 네브 호스트 역할을 하는 네브 디스플레이
백스택은
백스택은 뮤터블 스테이트 리스트
이제 스냅샷 스테이트 리스트
로 관리가 되는 그런 백스택
이거는 개발자가 직접 면수로 선언을 합니다
그리고 이제
네브 그래프 빌더 스코프에 있는
컴포저블
막 서브 내브게이션 컴포저블 다이알로그
에 역할을 하는 네브 엔트리
그리고 이제 라우트의 역할을 하는 네브 키
그리고 이제 네브 그래프의 역할을 하는 엔트리 프로바이더
그리고 이거는 이제 말 그대로 파이썬의 데코레이터 처럼
데코레이팅 해주는 그런 녀석이고요
scene은 이제 장면
scene이랑 scene 스트레이트는
이거와 연관이 됐다고 보시면 됩니다
그래서 백스택에서 두 개를 꺼내든가
아니면 뭐 다이얼로그를 꺼내든가
button sheet 를 꺼내든가
라고 하는 것은 scene과 두 개로 연관되어 있다고 보시면 됩니다
이거는 일단 다루진 않아서
그래서 어떻게 동작하냐 하면은
이 백스택은 개발자가 선언을 합니다
저희가 변수로서 선언을 해요
변수로서 선언을 하고
네브 디스플레이를 컴포넌트를 선언을 하면서
그 파라미터에 백스택을 넘겨줍니다
그리고 네브 디스플레이 코드를 보면서 하면 되겠네요
여기서 백스택에서
remember 네브 백스택 이라는 것을 하면은
이제 뮤터블 리스트를 상속하는
네브 백스택 이라는 것을 리턴을 합니다
그래서 이제 네브 백스택을 네브 디스플레이에 넣어주고
여기 엔트리 프로바이더
네브 그래프에 해당하는 엔트리 프로바이더에다가
키를 받아와서 웬몬으로 처리를 합니다
우선 기본적으로는 웬몬으로 처리를 해서
웬에 키를 넣어주고
이제 타입 변환을 자동으로 해줬던 것 같은데
정확한 그 개념은 몰라서
이렇게 웬으로 넣어주면은
이 웬 블록 안에서는 이 키가
키가 라우트 뷰로 맵핑이 되면서
이 키의 이제 알규먼트에 접근을 할 수 있습니다
키점 아이디 이렇게 하는 식으로
그래서 인자 전달은 그냥 백스택에다가
백스택 이라는 리스트에다가
여기 그냥 이런 시리얼라이저블한 코드를 넣어주면 됩니다
데이터 클래스를
근데 얘네들은 네브 키를 상속해야 합니다
이제 라우트의 개념이고
그래서 키점 아이디
이제 라우트에 123이란 인자를 넣어주고
받는 쪽에서는 그냥 키의 인자에 접근을 하면은 받아올 수 있습니다
이 부분은 아까 말씀드렸던 거고
엔트리 프로바이더는
그 이 안에 있는 엔트리들을 모두 꾸며주는 역할이에요
그래서 주요한 걸로는
이제 힐트 뷰모델처럼
제트팩의 힐트 뷰모델처럼
이제 그 뷰모델의 라이프사이클 오너를
내부 엔트리에 속하게 해주는
그렇게 해서
이제 엔트리가 죽으면
힐트 뷰모델도 죽고
이렇게 생명주기를 갖게 해주는
요런 녀석이랑
이제 뒤로 가기
이제 디테일 화면으로 들어갔다가
다시 리스트 화면으로 돌아왔을 때
그 리스트에 있는 텍스트 필드 스테이트나
막 뭐 스크롤 상태들
요런 것들을 유지하게 해주는
이제 다른 화면으로 갔다가 다시 돌아왔을 때
상태를 유지하게 해주는
뭐 Remember Saveable State Holder Entry
얘는 기본적으로 달려있긴 합니다
이런 것들이 있고
엔트리 프로바이더는
요런 식으로
내부 그래프 빌더 점 해서
거기에 스코프에서 하는 것처럼
이렇게 확장함수를 만들어서
이렇게 만들 수도 있고요
요런 식으로 구현을 하면은
멀티모델까지 해서
각각 멀티모델에 구현을 해줄 수 있습니다
요 부분들은
사실상 말로 설명하기에는
요 부분은
저 부분은 너무 설명하기가 너무 어려워서
엔트리 프로바이더라는
DSL을 사용해서 이렇게 만들 수도 있고
요거는 내부에 요런 식으로 구현이 되어 있습니다
그래서 요런 스코프에서
엔트리
라는 함수에서 이렇게 열면은
그 안에 있는 콘텐트들이
엔트리 프로바이더에 쓱 넣어줘서
빌드가 되게 됩니다
그리고 바로 뷰모델로 전달을 하는 방법도 있는데요
뷰모델의 팩토리를 만들어서
팩토리에다가 원래 했던 것처럼
레포지토리를 넣어주는 것처럼
뷰모델을 바로 넘겨줄 수도 있습니다
그래서 마찬가지로 키에 접근해서
여기 뷰모델 팩토리에 키에다 넣어주면 됩니다
그리고 힐트는
어시스티드라는 거가 있는데
이 어시스티드는 컴파일 타임에
타입 추론이 안 되는 거를
런타임에 타입 추론을 해서
수동 DI를 하겠다라는 느낌의
어노테이션으로 봐주면 될 것 같습니다
어차피 런타임에 되는
DI 모듈이니까
그냥 넣어주면 되더라고요
인자로에다가
그렇습니다
감사합니다

---

### 질문 1 : Q. Nav3 는 백스택 때문에 탄생하게 된 것인가요?
그럼 저도 간단하게 하나만 먼저 질문하겠습니다
네비게이션 3는
백스텝 때문에
탄생을 하게 된 건가요?
화면 적응형 레이아웃에 맞추기 위함이랑
크게 두 개는
그거랑
싱글소스 오브 트루스트를
만족시키기 위해서
아 네 맞습니다
두 가지인 것 같아요
개발자가 백스텝을 직접 관리하는 거랑
감사합니다

### 질문 2 : Q. 백스택이 비어있는 경우에는 어떤 현상이 발생하는지?
아 리스트가 비어있는 경우요?
아
아
음
그거까지는 찾아보지 않았는데
그게 없으면은
팝했을 때
백스텝이 비어있으면은
일단 통상 앱이 꺼지니까
내부 디스플레이가
한번 요거는 찾아봐야 될 것 같습니다
안에 사이드 이펙트로
그거를 감지를 해서 실행이 되는지
요거는 찾아봐야 될 것 같습니다
네
여기서는 다른
조금 더 다른 개념을 쓰는데

### 질문 3 : Q. Nav3 에서의 중첩 NavGraph 개념?
중첩 그래프처럼 백 스택 안에 있는 백 스택의 느낌을 사용하는 것 같아요
그래서 이제 바텀 내비게이션에 해당하는 탑 레벨 스택 부분을 말씀드렸어야 되는데
탑 레벨 스택들을 선언을 하고
예를 들면은 바텀 탭에 홈 조회 신고 마이라는 탭이 4개 있었으면
각각의 탑 레벨 라우트가 각각의 서브 스택을 가질 수 있는 느낌으로 설계가 된 것 같습니다
설계가 됐다기 보다는 가이드에서 이렇게 가이드를 해 주더라고요
중첩의 느낌으로 해도 괜찮을 것 같아요
중첩 그래프를 쓴 이유가 블랙박스에 접근하기 위해서라고 생각을 하는데
이제 저희가 그냥 백 스택을 잘 지정해 줄 수 있으면은
저희가 원하는 인덱스를 파인드를 해서 거기 앞에다가 넣던가
뒤에다가 넣던가 할 수도 있고
이건 잠깐 살짝 달라진 것 같은데
왜 이런 식으로 가이드를 줬는지는 한번 더 찾아봐야 될 것 같은데
중첩 개념은 각각의 맵 형태로 관리를 하더라고요
이렇게 코드에서 서브 스택, 맵, 네브 백 스택 해가지고
답변하기가 굉장히 어렵네요

### 질문 4 : Nav3 를 도입하고 싶을 때 어떻게 팀들을 설득할 것인지?

그러면 만약에 프로젝트 팀에서 네비게이션 툴을 사용하다가
갑자기 네비게이션 3를 도입하고 싶으시면
혹시 어떻게 팀들을 설득하실 건가요?
제가 도입하고 싶다 하면요
그런 상황이라면 필요해서 라고 생각을 하는데
그런 상황이 필요하다면
태블릿을 겨냥한다거나 그런 상황일 것 같아요
그래서 약간 요거를
네브 툴로 해보진 않았지만
네브 툴로 했을 때
요런 어려움이 있을 것 같다
적응형 레이아웃이나 큰 화면에 대응했을 때
약간 네브 툴로 구현했을 때의 문제점을 가지고 설득을 할 것 같아요
음 감사합니다
또 굉장히 낯선 코드들이라서
저도 사실

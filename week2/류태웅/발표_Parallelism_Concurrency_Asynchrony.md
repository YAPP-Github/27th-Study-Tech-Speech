## 발표 텍스트
제가 이번에 발표할 내용은 병렬성, 동시성, 비동기성 세 가지에 대해서 좀 더 자세히 파는 내용을 조사했습니다. 지난번에 제가 이 부분에 대해서 잘못 설명한 것을 발견하고 이 부분에 대해서 확실하게 모르고 있다는 것을 파악하여 공부하게 되었습니다. 먼저 병렬성과 동시성의 차이가 무엇인지에 대해서 시작하겠습니다. 이 둘의 공통점은 여러 가지의 태스크를 동시 처리한다는 데에 있습니다. 이 유사성 때문에 저를 포함해서 개발 처음 하시는 분들이 많이 혼동한다고 알려져 있습니다.
병렬성은 여러 가지 리소스를 사용하는 방식으로, 여러 CPU 코어를 활용하여 하나의 코어만 사용하는 것이 아니라 여러 태스크들을 여러 코어에 분리해서 빠르게 처리되도록 설정하는 방식입니다. 특징을 살펴보면 하나의 태스크를 여러 가지 서브 태스크로 분리하고, 주 목적은 단일 작업의 지속시간인 레이턴시를 줄이는 것, 즉 서브 태스크들의 집합체를 얼마나 빠르게 끝낼 수 있는가가 핵심입니다. 분할된 작업들이 각각의 코어로 분류되면서 효율적으로 진행되고, 가용할 수 있는 코어가 있다면 각 스레드가 가용 코어마다 배정되는 방식입니다. 이를 피라냐 떼가 큰 먹이를 먹어치우는 것에 비유할 수 있는데, 하나의 큰 태스크를 먹이로, 피라냐 떼를 스레드로 비유하여 여러 서브 태스크들이 하나의 과제를 해결한다고 이해할 수 있습니다.
동시성은 병렬성과 달리 제한된 리소스에서 효율적으로 스케줄링하는 것이 핵심입니다. 병렬성이 가용할 수 있는 모든 리소스를 활용한다면, 동시성은 제한된 리소스에서 스케줄링한다는 점에서 확실히 차이가 있습니다. 동시성의 주 목표는 처리량(throughput)으로, 단위 시간당 처리할 수 있는 가능한 작업 수를 최대화하는 것입니다. 수많은 태스크들에 대해서 얼마나 많이 처리할 수 있는지가 관건이며, 리소스가 제한되어 있으니 각 태스크들이 제한된 리소스를 두고 경쟁하면서 중간중간 실행되는 방식입니다. 병렬성은 코어의 개수가 중요하지만, 동시성에서는 스레드가 얼마든지 생성되어도 제한된 리소스 내에서 처리합니다. 이를 도시에서 달리는 자동차에 비유할 수 있는데, 이미 제한된 도시 거리 폭 내에서 어떻게 자동차, 즉 스레드가 실행될 것인지를 스케줄링하는 것입니다.
스레드는 이 두 가지 기능을 동시에 수행하는데, 병렬성에서는 공간적 스케줄링으로 코어에 대한 분류를 담당하고, 동시성에서는 시간적 스케줄링으로 제한된 코어에서 여러 작업을 처리하는 방식을 담당합니다. 병렬성은 공간을 강조하고 동시성은 시간을 강조한다고 볼 수 있습니다.
다음으로 비동기성이라는 단어에 대해 이해를 돕고자 코틀린 문서를 통해 어의적인 정의를 파악했습니다. 비동기 프로그래밍은 블로킹을 방지하기 위한 프로그래밍으로, 결국 논블로킹 프로그래밍이며 동시성의 한 종류라고 이해할 수 있습니다. 동시성이 제한된 리소스에서의 업무 처리라면, 그 방식 중 하나가 비동기 프로그래밍, 즉 블로킹을 하지 않는 프로그래밍입니다.
비동기 프로그래밍을 구현하는 방식으로는 스레딩, 콜백, 프로미스, Rx, 코루틴 등이 있습니다. 어... 잠시만요, 이것 자체가 다 비동기 프로그래밍이라고 하기에는 약간 소지가 있을 것 같은데, 이게 블로킹을 방지하기 위한 기법들을 나열했다고 보시면 될 것 같습니다. 스레딩은 논블로킹도 가능하지만 블로킹도 가능하며, 멀티 스레딩에서는 블로킹이 발생하고 싱글 스레드에서는 논블로킹으로 구현할 수 있지만 컨텍스트 스위치 문제와 스레드의 높은 비용, 일반 스레드의 제한된 개수 같은 문제가 있습니다. 콜백 방식은 블로킹을 피할 수 있는 방식이지만 자바스크립트에서 볼 수 있는 콜백 헬 문제가 있습니다. 퓨처와 프로미스는, 어... 이게 자바스크립트에서 제가 한번 사용하면서 봤던 건데, 프로미스 타입을 통해서 블로킹하지 않도록 특정 코드를 실행하고 다음 코드로 진행할 수 있도록 하는 기능이 있습니다. 이게 async-await 방식이었던 걸로 아는데, 그 방식을 하나 소개하고 있고, 물론 코루틴에서도 async-await 코드가 있는 것도 이것과 유사한 방식이라고 보시면 됩니다. Rx는 스트림 관련 처리 기법으로 옵저버 패턴을 확장한 것이며, 플로우가 있긴 하지만 어... 블로킹하지 않고 처리할 수 있는 방법 중 하나입니다.
마지막으로 코루틴과 스레드의 차이점은 블로킹을 하는 것이 아니라 서스펜드, 즉 중단하고 재개한다는 것이 큰 차이입니다.

## 질의응답
Q1. 컨텍스트 스위칭이란 무엇인가요?
컨텍스트 스위칭은 하나의 스레드가 특정 코어 위에서 사용하고 있을 때, 다른 스레드가 해당 리소스를 사용해야 하고 특정 기준으로 그 코어 사용을 하기 위해서 스케줄러가 원래 기존의 스레드를 유휴 상태로 변경시켜주고, 그 다음에 다른 스레드가 실행되도록 하는 것으로 이해했습니다.

Q2. 자바 스레드와 OS 스레드의 관계는 어떻게 되나요?
자바 스레드는 제가 이해한 바로는 이 스레드 하나가 OS에서 생성되는 스레드와 동일한 것으로 알고 있습니다. 코루틴에서 쓰이는 스레드는 그 스레드 안에서 여러 가지 코드 실행을 하는 것으로 알고 있는데, 이 스레드 하나 자체를 제어하게 되면 이 스레드 내에서 그 코어 비용이 발생하는데, 그것 전체를 제어하게 되는 경우에는 그 스레드 내부의 코드 제어보다 훨씬 무겁기 때문에 비용이 크다라고 이해했습니다.

Q3. 그 스레드 하나의 스레드에서 연산이 많은 작업을 처리한다고 이해하면 될까요?
자바 스레드 내에서는 가용하는 코어 내에 할당되어서 스레드가 실행되고, 그게 종료되면 그 다음으로 넘어가지 않나 생각합니다. 그 종료되기 전에는 컨텍스트 스위칭이 발생하지 않으면 계속 대기 상태이지 않나 생각합니다.

## 부족한 부분
1. 컨텍스트 스위칭
   컨텍스트 스위칭은 기존 스레드를 유휴(idle) 상태가 아닌 대기(waiting) 또는 준비(ready) 상태로 변경하며, 스레드의 실행 컨텍스트(레지스터, 프로그램 카운터 등)를 저장한 후 새로운 스레드의 컨텍스트를 복원하는 과정이다.
2. 스레드 제어 비용
   OS 레벨의 스레드 컨텍스트 스위칭은 커널 모드 전환, 레지스터 저장/복원, 캐시 무효화 등의 오버헤드가 발생하여 비용이 크다.
3. 스레드 대기 상태
   스레드가 실행 중이면 실행(running) 상태이며 다른 스레드는 준비(ready) 큐에서 대기하고, 컨텍스트 스위칭은 타임 슬라이스 만료, I/O 대기, 우선순위 선점 등 다양한 이유로 작업 종료 전에도 발생할 수 있다.
4. 스레드 실행 모델
   현대 OS는 선점형 멀티태스킹을 사용하여 스레드가 종료되지 않아도 일정 시간(타임 슬라이스) 후 강제로 컨텍스트 스위칭을 수행하며, 스레드는 코어에 고정되지 않고 스케줄러에 의해 동적으로 할당된다.
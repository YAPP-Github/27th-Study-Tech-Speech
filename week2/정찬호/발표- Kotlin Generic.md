제네릭의 타입 정보 소거(Type Erasure)라는 개념과 왜 제네릭의 타입 파라미터에는 원시 타입이 아니라 참조 타입만 사용할 수 있는지에 대해 정리해봤습니다.

먼저 자바 컴파일러는 제네릭 타입을 처리할 때 타입 파라미터를 제거하고, 해당 타입 파라미터를 경계(bound) 로 대체합니다.

이 설명이 처음에는 잘 와닿지 않았습니다. 그래서 이 개념을 하나씩 천천히 이해해 보았습니다.

예를 들어 Int 타입의 리스트를 제네릭으로 선언했을 때, 디컴파일된 바이트 코드를 확인해 보면 실제로는 단순한 ArrayList로 변환되어 있는 것을 볼 수 있습니다.

즉, 이 말은 제네릭 타입이 런타임에는 어떤 타입의 원소를 저장하는지 알 수 없다는 의미입니다.

이를 검증하기 위해 Int 타입의 리스트와 String 타입의 리스트를 각각 선언한 뒤 리플렉션을 사용해 두 타입을 비교해 보았습니다.

결과는 두 경우 모두 true였습니다.

그 이유는 앞서 바이트 코드에서 확인한 것처럼 제네릭 타입이 Int이든 String이든 상관없이 런타임에는 모두 동일한 ArrayList 타입으로 치환되기 때문입니다.

이러한 문제를 해결하는 방법 중 하나가 reified 키워드를 사용하는 것입니다.

예제 코드에서 제네릭 함수의 타입 파라미터를 런타임에 사용하려고 하면 컴파일러 에러가 발생하는 것을 볼 수 있습니다.

이 역시 타입 소거 때문에 실행 시점에는 타입 정보를 확인할 수 없기 때문입니다.

이를 해결하기 위해 reified 키워드를 사용할 수 있는데, 이 키워드는 inline 함수에서만 사용 가능합니다.

그 이유는 inline 키워드를 붙이면 컴파일러가 함수 본문을 호출 지점에 그대로 복사하기 때문입니다.

이 과정에서 컴파일러는 복사된 실제 타입 인자를 알 수 있게 되고, 그 결과 런타임에서도 타입 정보를 사용할 수 있게 됩니다.

이렇게 타입 소거의 제약을 우회하는 방식을 코틀린에서는 실체화된 타입 파라미터(reified type parameter) 라고 부릅니다.

실제로 제네릭 함수에 String 타입으로 "hello"를 전달하고 1, 2, 3을 넣어보면 false가 반환되는 것을 확인할 수 있습니다.

앞선 리스트 예제에서는 Int와 String이 모두 동일한 ArrayList로 대체되었지만,

이 경우에는 String 타입 정보가 런타임까지 유지되는 것을 확인할 수 있습니다.

다음으로, 처음 언급했던 “타입 파라미터를 경계로 대체한다”는 말에서 경계(bound) 개념을 살펴보겠습니다.

경계란 해당 타입 파라미터가 어떤 타입을 사용할 수 있는지를 제한하는 규칙입니다.

예를 들어 타입 파라미터의 경계를 Number로 지정하면 이 Box 클래스에 들어올 수 있는 타입은 반드시 Number의 하위 타입이어야 합니다.

이 경우 실제로 Int 타입을 문제없이 사용할 수 있습니다.

반대로 아무런 경계를 지정하지 않으면 제네릭 타입은 기본적으로 가장 상위 타입인 Any로 취급됩니다.

자바 기준으로는 이 Any가 Object로 대응되기 때문에 결과적으로 Object로 대체됩니다.

오라클 자바 튜토리얼 예제를 기반으로 경계가 있을 때와 없을 때를 비교해 보았습니다.

경계를 지정하지 않은 경우 디컴파일된 코드에서는 모두 Object로 대체되는 것을 확인할 수 있습니다.

반면 Comparable 같은 인터페이스를 경계로 지정한 경우에는 해당 타입 정보가 유지되는 것을 볼 수 있습니다.

지금까지 본 것처럼 제네릭 타입 파라미터에는 Comparable, String 같은 참조 타입만 사용할 수 있습니다.

이는 제네릭 타입 파라미터가 기본적으로 Object로 대체되기 때문입니다.

자바에서 Object는 모든 객체 타입의 최상위 타입이지만 원시 타입은 이 타입 계층 구조에 포함되지 않습니다.

따라서 int를 제네릭에 사용하려면 반드시 Integer 같은 래퍼 타입으로 감싸야 합니다.

코틀린에서는 원시 타입과 래퍼 타입을 개발자가 직접 구분하지 않아도 됩니다.

Int, Double 등을 사용하면 컴파일러가 상황에 따라 자동으로 박싱과 언박싱을 수행합니다.

원시 타입 배열을 사용하고 싶다면 IntArray 같은 전용 배열 타입을 사용하면 되고, 박싱된 배열이 필요하다면 Array<Int> 형태를 사용하면 됩니다.

실제로 IntArray를 디컴파일해 보면 진짜 원시 타입 배열로 변환되는 것을 확인할 수 있습니다.

이러한 구조는 Value class를 사용할 때 의도치 않은 문제를 만들기도 합니다.

Value class는 겉으로는 객체처럼 보이지만 실제로는 원시 타입처럼 박싱 없이 사용할 수 있다는 장점이 있습니다.

하지만 Value class를 제네릭 타입 파라미터로 사용하면 내부적으로 박싱이 발생합니다.

디컴파일해 보면 box와 unbox 메서드가 자동으로 생성되어 있는 것을 확인할 수 있습니다.

제네릭에 사용되는 경우 이 box 메서드가 호출되어 결과적으로 객체로 저장됩니다.

즉, Value class의 장점인 “원시 타입처럼 동작한다”는 이점을 제네릭 환경에서는 온전히 누릴 수 없습니다.

이 문제는 Kotlin KEEP 저장소에서도 논의되고 있는 주제입니다.

KEEP는 코틀린 사용자들이 언어 개선 아이디어를 제안하고 논의하는 공식 채널입니다.

이곳에서도 Value class와 제네릭의 박싱 문제, 그리고 JVM의 타입 소거 제약에 대해 다루고 있습니다.

그중 하나로 Value class와 원시 타입을 저장할 수 있는 새로운 배열 개념인 V-Array가 제안되었지만 아직 실제로 도입되지는 않은 상태입니다.

### 질문
#### out과 in 에 대해 설명해주세요
out과 in을 구분하는 핵심 개념은 다음과 같다.
> 이 타입을 넣을 건가? 꺼낼 건가?

1. out
값을 "꺼내기 위한" 용도로 제네릭 타입을 외부에서 꺼낼 때 하위 타입으로 캐스팅 가능 여부를 허용한다.
```
open class Animal {
    override fun toString() = "Animal"
}

class Dog : Animal() {
    override fun toString() = "Dog"
}

class Box<out T>(private val value: T) {
    fun get(): T = value
}

fun printAnimal(box: Box<Animal>) {
    println(box.get())
}

fun main(){
    val dogBox: Box<Dog> = Box(Dog())
    val animalBox: Box<Animal> = dogBox
    
    printAnimal(dogBox)
}
```

2. in
값을 "삽입하기 위한" 용도로 제네릭 타입을 외부에서 인자를 넣을 때 하위 타입으로 캐스팅 가능 여부를 허용한다.
```
open class Animal {
    override fun toString() = "Animal"
}

class Dog : Animal() {
    override fun toString() = "Dog"
}

class Box<in T> {
    fun put(value: T) {
        println(value)
    }
}


fun main(){
    val animalBox: Box<Animal> = Box()
    val dogBox: Box<Dog> = animalBox

    dogBox.put(Dog())

}
```
